import { Queue, Worker } from "bullmq";
import { db } from "../lib/db.js";
import {
  Connection,
  Keypair,
  ParsedAccountData,
  PublicKey,
  sendAndConfirmTransaction,
  Transaction,
} from "@solana/web3.js";
import bs58 from "bs58";
import dotenv from "dotenv";
import {
  getOrCreateAssociatedTokenAccount,
  createTransferInstruction,
} from "@solana/spl-token";
dotenv.config();

const payoutQueue = new Queue("payout-queue", {
  connection: {
    host: process.env.URI,
    port: 6379,
    username: "default",
    password: process.env.PASSWORD,
  },
});

export async function putItemInPayoutQueue(id: string) {
  // ! Send payout id here
  console.log(`first`);
  await payoutQueue.add(
    "payment out",
    {
      id,
    },
    // TODO: remove this after moving the producton
    { delay: 100 }
  );
}

const payoutWorker = new Worker(
  "payout-queue",
  async (job) => {
    // if (1 == 1) return;
    const payout = await db.payout.findUnique({
      where: {
        id: job.data.id,
      },
    });
    if (!payout || payout.status !== "PRE_PROCESSING") return;

    const user = await db.user.findUnique({
      where: {
        username: payout.generatedTo,
      },
    });
    const organization = await db.organization.findUnique({
      where: {
        id: payout.organizationId,
      },
    });
    await db.$transaction(async (tx) => {
      if (!user || !user.publicKey) {
        await tx.payout.update({
          where: { id: payout.id },
          data: {
            status: "UNCOLLECTED",
          },
        });
        return;
      }
      if (
        !organization ||
        organization.balance < payout.amount ||
        !organization.id
      ) {
        await tx.payout.update({
          where: { id: payout.id },
          data: {
            status: "FAILED",
          },
        });
        return;
      }

      // now they have everything okay so lets move on
      // creating the s3 wallet transaction

      // !! This is not the perfect case if the payment fails then user could loss his/her money
      const keypair = Keypair.fromSecretKey(
        bs58.decode(process.env.WALLET_SECRET ?? "")
      );
      const connection = new Connection(
        "https://solana-devnet.g.alchemy.com/v2/ggElObM2tMIgAKq7VyByiJQjMn58Tg0R",
        "confirmed"
      );
      const MINT_ADDRESS = new PublicKey(
        "Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr"
      );
      let sourceAccount = await getOrCreateAssociatedTokenAccount(
        connection,
        keypair,
        new PublicKey(MINT_ADDRESS),
        keypair.publicKey
      );
      let destinationAccount = await getOrCreateAssociatedTokenAccount(
        connection,
        keypair,
        new PublicKey(MINT_ADDRESS),
        new PublicKey(user.publicKey)
      );

      async function getNumberDecimals(mintAddress: string): Promise<number> {
        const info = await connection.getParsedAccountInfo(
          new PublicKey(MINT_ADDRESS)
        );
        const result = (info.value?.data as ParsedAccountData).parsed.info
          .decimals as number;
        return result;
      }

      const transaction = new Transaction().add(
        createTransferInstruction(
          sourceAccount.address,
          destinationAccount.address,
          keypair.publicKey,
          (payout.amount - 2) * 1000_000
        )
      );

      const signature = await sendAndConfirmTransaction(
        connection,
        transaction,
        [keypair]
      );
      // create payment
      const payment = await db.payment.create({
        data: {
          organizationId: organization.id,
          userId: user.id,
          initialAmount: payout.amount,
          charges: 2,
          transferredAmount: payout.amount - 2,
          signature,
          paidToCompany: false,
          body: `Payout of bounty is given to user ${user.username} generated by ${payout.generatedBy} of amount ${payout.amount}. user will receive ${payout.amount}`,
        },
      });
      // create wallet trans

      const walletLast = await db.walletTransaction.findFirst({
        orderBy: {
          createdAt: "desc",
        },
      });
      let walletBalance = walletLast?.amount
        ? walletLast.amount - payout.amount - 2
        : 0;
      await db.walletTransaction.create({
        data: {
          type: "DEBIT",
          userId: user.id,
          amount: payout.amount - 2,
          totalWalletAmount: walletBalance,
          signature,
          paymentId: payment.id,
          body: `For org ${organization.name} paid for bounty to user ${user.username}`,
        },
      });
      await db.organization.update({
        where: { id: organization.id },
        data: {
          balance: { decrement: payout.amount },
        },
      });

      // update payout
      await db.payout.update({
        where: {
          id: payout.id,
        },
        data: {
          paymentId: payment.id,
          status: "COLLECTED",
        },
      });
    });
  },
  {
    connection: {
      host: process.env.URI,
      port: 6379,
      username: "default",
      password: process.env.PASSWORD,
    },
  }
);
