import { Queue, Worker } from "bullmq";
import { db } from "../lib/db.js";
import {
  clusterApiUrl,
  Connection,
  Keypair,
  ParsedAccountData,
  PublicKey,
  sendAndConfirmTransaction,
  Transaction,
  VALIDATOR_INFO_KEY,
} from "@solana/web3.js";
import bs58 from "bs58";
import dotenv from "dotenv";
import {
  getOrCreateAssociatedTokenAccount,
  createTransferInstruction,
} from "@solana/spl-token";
dotenv.config();

const payoutQueue = new Queue("payout-queue", {
  connection: {
    host: process.env.URI,
    port: 6379,
    username: "default",
    password: process.env.REDIS_PASSWORD,
  },
});

const payoutWorker = new Worker(
  "payout-queue",
  async (job) => {
    // if (1 == 1) return;
    try {
      const payout = await db.payout.findUnique({
        where: {
          id: job.data.id,
        },
      });
      if (!payout) return;
      console.log(payout.status);
      if (
        !(payout.status === "PRE_PROCESSING" || payout.status === "UNCOLLECTED")
      )
        return;

      const user = await db.user.findUnique({
        where: {
          username: payout.generatedTo,
        },
      });

      const organization = await db.organization.findUnique({
        where: {
          id: payout.organizationId,
        },
      });
      if (
        !organization ||
        organization.balance < payout.amount ||
        !organization.id
      ) {
        await db.payout.update({
          where: { id: payout.id },
          data: {
            status: "FAILED",
          },
        });
        return;
      }
      if (!user || !user.publicKey) {
        await db.payout.update({
          where: { id: payout.id },
          data: {
            status: "UNCOLLECTED",
          },
        });
        return;
      }

      // now they have everything okay so lets move on
      // creating the s3 wallet transaction

      // !! This is not the perfect case if the payment fails then user could loss his/her money
      const keypair = Keypair.fromSecretKey(
        bs58.decode(process.env.WALLET_SECRET ?? "")
      );
      // alchemy is not working
      // ! move alchemy to the .env file
      const connection = new Connection(
        // "https://solana-devnet.g.alchemy.com/v2/ggElObM2tMIgAKq7VyByiJQjMn58Tg0R",
        clusterApiUrl("devnet"),
        "confirmed"
      );

      const MINT_ADDRESS = new PublicKey(
        "Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr"
      );
      let sourceAccount = await getOrCreateAssociatedTokenAccount(
        connection,
        keypair,
        new PublicKey(MINT_ADDRESS),
        keypair.publicKey
      );
      let destinationAccount = await getOrCreateAssociatedTokenAccount(
        connection,
        keypair,
        new PublicKey(MINT_ADDRESS),
        new PublicKey(user.publicKey)
      );

      async function getNumberDecimals(mintAddress: string): Promise<number> {
        const info = await connection.getParsedAccountInfo(
          new PublicKey(MINT_ADDRESS)
        );
        const result = (info.value?.data as ParsedAccountData).parsed.info
          .decimals as number;
        return result;
      }
      console.log(`transaction`);

      const transaction = new Transaction().add(
        createTransferInstruction(
          sourceAccount.address,
          destinationAccount.address,
          keypair.publicKey,
          (payout.amount - 1) * 1000_000
        )
      );

      const latestBlockhash = await connection.getLatestBlockhash("confirmed");
      transaction.recentBlockhash = latestBlockhash.blockhash;

      console.log(`signature is below this`);
      const signature = await sendAndConfirmTransaction(
        connection,
        transaction,
        [keypair],
        { commitment: "finalized" }
      );
      console.log(signature);
      // create payment
      await db.$transaction(async (tx) => {
        const payment = await tx.payment.create({
          data: {
            organizationId: organization.id,
            userId: user.id,
            initialAmount: payout.amount,
            charges: 1,
            transferredAmount: payout.amount - 1,
            signature,
            paidToCompany: false,
            body: `Payout of bounty is given to user ${user.username} generated by ${payout.generatedBy} of amount ${payout.amount}. user will receive ${payout.amount - 1}`,
          },
        });
        // create wallet trans

        const walletLast = await tx.walletTransaction.findFirst({
          orderBy: {
            createdAt: "desc",
          },
        });
        let walletBalance = walletLast?.amount
          ? walletLast.amount - payout.amount - 1
          : 0;
        await tx.walletTransaction.create({
          data: {
            type: "DEBIT",
            userId: user.id,
            amount: payout.amount - 1,
            totalWalletAmount: walletBalance,
            signature,
            paymentId: payment.id,
            body: `For org ${organization.name} paid for bounty to user ${user.username}`,
          },
        });
        await tx.organization.update({
          where: { id: organization.id },
          data: {
            balance: { decrement: payout.amount },
          },
        });

        // update payout
        const newPayout = await tx.payout.update({
          where: {
            id: payout.id,
          },
          data: {
            paymentId: payment.id,
            status: "COLLECTED",
          },
        });
      });
    } catch (e) {
      console.log(e);
    }
  },
  {
    connection: {
      host: process.env.URI,
      port: 6379,
      username: "default",
      password: process.env.REDIS_PASSWORD,
    },
  }
);
export async function putItemInPayoutQueue(id: string) {
  console.log`item is added to queue`;
  await payoutQueue.add(
    "payment out",
    {
      id,
    },
    // TODO: try to get the delay from the .env file
    { delay: 1000 }
  );
}
